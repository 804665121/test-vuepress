(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{292:function(e,n,a){"use strict";a.r(n);var t=a(13),l=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"watch注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#watch注意事项"}},[e._v("#")]),e._v(" watch注意事项")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("监视"),n("strong",[e._v("ref")]),e._v("定义的响应式数据,使用"),n("strong",[e._v("watch监视一个值")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' let sum = ref(1);\n immediate:true 表示初始化的时候执行一次\n  watch(\n      sum,\n      (newVal, oldVal) => {\n        console.log(newVal, oldVal, "sum修改了");\n      },\n      { immediate: true }\n    );\n')])])])]),e._v(" "),n("li",[n("p",[e._v("监控多个"),n("strong",[e._v("ref")]),e._v("值的情况,"),n("strong",[e._v("监视多个值")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('监视多个值的情况,watch的第一个值接收的是一个数据,返回的newval和oldVal也是一个数据\n\n    let sum = ref(1);\n    let msg = ref("hello");\n    watch([sum, msg], (newVal, oldVal) => {\n          console.log(newVal, oldVal, "sum修改了");\n    });\n')])])])]),e._v(" "),n("li",[n("p",[e._v("监视"),n("strong",[e._v("reactive")]),e._v(" 定义的响应式数据的"),n("strong",[e._v("全部属性")])]),e._v(" "),n("ul",[n("li",[e._v("使用"),n("strong",[e._v("watch")]),e._v("监测的时候无法准确监测到到"),n("strong",[e._v("oldVal")]),e._v(".")]),e._v(" "),n("li",[e._v("强制开启了"),n("strong",[e._v("deep")]),e._v("深度监视(deep无法关闭)")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let person = reactive({\n      name: "zangsan",\n      age: 19,\n      job: {\n        j1: 20,\n      },\n    });\nwatch(person, (newVal, oldVal) => {\n   console.log(newVal, oldVal, "person 监视的值");\n});\n')])])])]),e._v(" "),n("li",[n("p",[e._v("监视"),n("strong",[e._v("reactive")]),e._v(" 定义的响应式数据的"),n("strong",[e._v("某个属性")])]),e._v(" "),n("ul",[n("li",[e._v("需要使用箭头函数的方式,才能监测要数据变化 ,直接写无法使用")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' let person = reactive({\n      name: "zangsan",\n      age: 19,\n      job: {\n        j1: 20,\n      },\n    });\n    watch(\n      () => person.age,\n      (newVal, oldVal) => {\n        console.log(newVal, oldVal, "person.age 监视的值");\n      }\n    );\n')])])])]),e._v(" "),n("li",[n("p",[e._v("监视"),n("strong",[e._v("reactive")]),e._v(" 定义的响应式数据的"),n("strong",[e._v("某些属性")])]),e._v(" "),n("p",[e._v("与"),n("strong",[e._v("ref")]),e._v("的响应式数据一致也是传递一个数组")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\n  let person = reactive({\n      name: "zangsan",\n      age: 19,\n      job: {\n        j1: 20,\n      },\n    });\n watch([() => person.age, () => person.name], (newVal, oldVal) => {\n      console.log(newVal, oldVal, "person.age 监视的值");\n});\n')])])])]),e._v(" "),n("li",[n("p",[e._v("特殊情况")]),e._v(" "),n("p",[e._v("监视"),n("strong",[e._v("reactive")]),e._v("定义的对象中的"),n("strong",[e._v("某个属性")]),e._v(",开启"),n("strong",[e._v("deep:true")]),e._v("有效")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' let person = reactive({\n      name: "zangsan",\n      age: 19,\n      job: {\n        j1: 20,\n      },\n    });\n   watch(\n      () => person.job,\n      (newVal, oldVal) => {\n        console.log(newVal, oldVal, "person.job 监视的值");\n      },\n      { deep: true }\n    );//此处由于监视的是reactive定义的对象中的某个属性,所有deep配置有效果\n')])])]),n("p",[e._v("在watch中,使用"),n("strong",[e._v("ref")]),e._v("定一个的对象,在监视值的时候需要加上.value,")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' let person1 = ref({\n      name: "zangsan",\n      age: 19,\n      job: {\n        j1: 20,\n      },\n    });\n//第一种方式\n    watch(person1.value, (newVal, oldVal) => {\n      console.log(newVal, oldVal, "oldVal");\n    });\n  //第二种方式\n    watch(person1, (newVal, oldVal) => {\n      console.log(newVal, oldVal, "oldVal");\n    },{deep:true});\n')])])])])]),e._v(" "),n("h1",{attrs:{id:"_4-watcheffect函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-watcheffect函数"}},[e._v("#")]),e._v(" 4.watchEffect函数")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("watch")]),e._v("使用:既要指明函数的属性,也要指明监视的回调")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("watchEffect")]),e._v(":不需要指明监视哪个属性,监视的回调中用到哪个属性,那就监视哪个属性")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("watchEffect")]),e._v("有点像"),n("strong",[e._v("computed")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("但是"),n("strong",[e._v("computed")]),e._v("注重的是计算出来的值("),n("strong",[e._v("回调函数的返回值)")]),e._v(",所以必须要写返回值")])]),e._v(" "),n("li",[n("p",[e._v("而"),n("strong",[e._v("watchEffect")]),e._v("更注重的是过程("),n("strong",[e._v("回调函数的函数体")]),e._v("),所以不用写返回值.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('watchEffect所指定的回调中用到的数据只要发生改变,则直接执行回调\n watchEffect(() => {\n      const x = person.age;\n      console.log("回调执行了");\n });\n')])])])])])])])])}),[],!1,null,null,null);n.default=l.exports}}]);