{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{287:function(e,t,n){\"use strict\";n.r(t);var r=n(13),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"其它composition-api\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其它composition-api\"}},[e._v(\"#\")]),e._v(\" 其它Composition API\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"h4\",{attrs:{id:\"shallowreactive和shallowref\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#shallowreactive和shallowref\"}},[e._v(\"#\")]),e._v(\" shallowReactive和shallowRef\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[e._v(\"shallowReactive\")]),e._v(\":只处理对象最外层的响应式(浅响应式)\")]),e._v(\" \"),t(\"li\",[t(\"strong\",[e._v(\"shallowRef\")]),e._v(\": 只处理基本数据类型的响应式,不进行对象的响应式\")]),e._v(\" \"),t(\"li\",[e._v(\"什么时候使用?\\n\"),t(\"ul\",[t(\"li\",[e._v(\"如果又一个对象数据,结构比较深,但变卦时只是外层属性变化====>\"),t(\"strong\",[e._v(\"shallowReactive\")])]),e._v(\" \"),t(\"li\",[e._v(\"如果有一个对象数据,后续功能不会修改该对象中的属性,而是生新的对象来替代====>\"),t(\"strong\",[e._v(\"shallowRefÏ\")])])])])])]),e._v(\" \"),t(\"li\",[t(\"h4\",{attrs:{id:\"readonly和shallowreadonly\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readonly和shallowreadonly\"}},[e._v(\"#\")]),e._v(\" readonly和shallowReadonly\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"readonly:让一个响应式的数据变为只读(深只读)\")]),e._v(\" \"),t(\"li\",[e._v(\"shallowReadonly:让一个响应式数据变为只读的(浅只读)\")]),e._v(\" \"),t(\"li\",[e._v(\"应用场景:不希望数据被修改时\")])])]),e._v(\" \"),t(\"li\",[t(\"h4\",{attrs:{id:\"toraw与markraw\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#toraw与markraw\"}},[e._v(\"#\")]),e._v(\" toRaw与markRaw\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"toRew\\n\"),t(\"ul\",[t(\"li\",[e._v(\"作用:讲一个有\"),t(\"strong\",[e._v(\"reactive\")]),e._v(\"生成的\"),t(\"strong\",[e._v(\"响应式数据\")]),e._v(\"转为\"),t(\"strong\",[e._v(\"普通对象\")])]),e._v(\" \"),t(\"li\",[e._v(\"使用场景:用于读取响应式对象对应的普通对象,对这个普通对象的所有操作,不会引起页面的更新\")])])]),e._v(\" \"),t(\"li\",[e._v(\"markRaw\\n\"),t(\"ul\",[t(\"li\",[e._v(\"作用:标记一个对象,使其\"),t(\"strong\",[e._v(\"永远不会变成响应式对象\")])]),e._v(\" \"),t(\"li\",[e._v(\"应用场景:\\n\"),t(\"ul\",[t(\"li\",[e._v(\"有些值不应该被响应式的,例如复杂的第三方库\")]),e._v(\" \"),t(\"li\",[e._v(\"当渲染具有不可变数据源的大列表的时候,跳过响应式转换可以提高性能\")])])])])])])]),e._v(\" \"),t(\"li\",[t(\"h4\",{attrs:{id:\"customref\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#customref\"}},[e._v(\"#\")]),e._v(\" customRef\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[e._v(\"作用:创建一个自定义的ref,并对其依赖项跟踪和更新触发进行显示控制\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"实现防抖效果\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('<template>\\n  <h1>自定义ref</h1>\\n  <div>\\n    <input type=\"text\" v-model=\"keyword\" />\\n    <span>{{ keyword }}</span>\\n  </div>\\n</template>\\n\\n<script>\\nimport { customRef } from \"@vue/reactivity\";\\nexport default {\\n  setup() {\\n    // 防抖函数的实现\\n    function useCustomRef(value, delay = 2000) {\\n      return customRef((track, trigger) => {\\n        let timer;\\n        return {\\n          get() {\\n            console.log(value, \"get\");\\n            track();\\n            return value;\\n          },\\n          set(newVal) {\\n            console.log(newVal, \"值被修改l1111\");\\n            clearTimeout(timer);\\n            timer = setTimeout(() => {\\n              //默认等待2s之后再执行\\n              value = newVal;\\n              trigger();\\n            }, delay);\\n          },\\n        };\\n      });\\n    }\\n    let keyword = useCustomRef(\"hello\", 1000);\\n    return {\\n      keyword,\\n    };\\n  },\\n};\\n<\\/script>\\n\\n<style>\\n</style>\\n')])])])])])]),e._v(\" \"),t(\"li\",[t(\"h4\",{attrs:{id:\"provide与inject\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#provide与inject\"}},[e._v(\"#\")]),e._v(\" provide与inject\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[e._v(\"作用:实现\"),t(\"strong\",[e._v(\"祖孙之间\")]),e._v(\"的通信Ï\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"套路:父组件有一个\"),t(\"strong\",[e._v(\"provide\")]),e._v(\"选项来提供数据,孙组件有\"),t(\"strong\",[e._v(\"inject\")]),e._v(\"选项来使用这些数据\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"具体写法\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[e._v(\"祖组件写法\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('import { reactive,toRefs, provide } from \"vue\"; //引入provide\\n setup() {\\n    let person = reactive({\\n      name: \"章三\",\\n      age: 24,\\n      job: 20,\\n    });\\n\\n    provide(\"user\", person);\\n\\n    return {\\n      ...toRefs(person),\\n    };\\n  },\\n')])])])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"孙组件接收\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('import { inject } from \"vue\";\\nsetup() {\\n    let person = inject(\"user\");\\n    return {\\n      person,\\n    };\\n  },\\n')])])])])])]),e._v(\" \"),t(\"li\")])]),e._v(\" \"),t(\"li\",[t(\"h4\",{attrs:{id:\"响应式数据的判断\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#响应式数据的判断\"}},[e._v(\"#\")]),e._v(\" 响应式数据的判断\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[e._v(\"isRef\")]),e._v(\":检查一个值是否是\"),t(\"strong\",[e._v(\"ref\")]),e._v(\"对象\")]),e._v(\" \"),t(\"li\",[t(\"strong\",[e._v(\"isReactive\")]),e._v(\":检查一个对象是否是由\"),t(\"strong\",[e._v(\"reactive\")]),e._v(\"创建的响应式对象\")]),e._v(\" \"),t(\"li\",[t(\"strong\",[e._v(\"isReadonly\")]),e._v(\":检查一个对象是否是由\"),t(\"strong\",[e._v(\"readonly\")]),e._v(\"创建的只读代理\")]),e._v(\" \"),t(\"li\",[t(\"strong\",[e._v(\"isProxy\")]),e._v(\":检查一个对象是否是由\"),t(\"strong\",[e._v(\"reactive\")]),e._v(\"或者\"),t(\"strong\",[e._v(\"readonly\")]),e._v(\"方法创建的代理对象\")])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}